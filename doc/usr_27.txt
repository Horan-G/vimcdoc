*usr_27.txt*	For Vim version 6.1.		最后修改: 2001年9月3日

		     VIM 用户手册`- Bram Moolenaar 著
                                    Chimin Yen 译
				    
			     查找命令及模式


在第三章里, 我们曾经提到过几个简单的查找模式 |03.9|. Vim 能够胜任复杂得多的查
找. 本章将解释那些最常用到的模式. 而详细的说明可以查阅: |pattern|

|27.1|	忽略大小写
|27.2|	在文件尾折返
|27.3|	偏移
|27.4|	匹配重复性模式
|27.5|	多择一
|27.6|	字符域
|27.7|	字符类
|27.8|	匹配换行符
|27.9|	举例

下一章: |usr_28.txt|  折叠
前一章: |usr_26.txt|  重复
目  录: |usr_toc.txt|

==============================================================================
*27.1*	忽略大小写

默认情况下, Vim 的查找是大小写敏感的. 因此, "include", "INCLUDE", 和 "Include"
为三个各不相同的词, 而一次查找将仅仅匹配其中的一个.
   现在设定 'ignorecase' 选项: >

	:set ignorecase

再查找 "include", 现在它将匹配 "Include", "INCLUDE" 和 "InClUDe". (设定 
'hlsearch' 选项, 以快速查看哪儿有模式的匹配.)
   你可以撤销这个选项: >

	:set noignorecase

但是我们且保留这个设定, 并查找 "INCLUDE". 它匹配的文本就跟查找 "include" 时
一模一样. 现在我们设定 'smartcase' 选项: >

	:set ignorecase smartcase

如果你采用的模式里至少有一个大写字母, 查找就成了大小写敏感的. 该构想是, 你不
必键入大写字母, 也能查找到含有大写字母的词, 所以, 你若键入大写字母, 必然是因
为你要大小写敏感的匹配. 聪明!
    设定了这两个选项, 你找到以下匹配:

	模式			匹配	~
	word			word, Word, WORD, WoRd, etc.
	Word			Word
	WORD			WORD
	WoRd			WoRd


单个模式里的大小写

如果你想忽略一个特定的模式里的大小写, 那么, 在模式前附加 "\c" 字符串就行了.
附加 "\C" 将使该模式的匹配大小写敏感. 这排除了 'ignorecase' 和 'smartcase' 
选项的影响, 当 "\c" 或 "\C" 起作用时, 它们设成什么值无关紧要.

	模式			匹配	~
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd, etc.
	\cWord			word, Word, WORD, WoRd, etc.

采用 "\c" 和 "\C" 的好处在于它粘附在模式上. 因此, 如果你从查找历史记录里选个
模式来重复, 那么同样的结果就会产生, 不管 'ignorecase' 或 'smartcase' 是否改了.

	注意:
	在查找模式中使用以 "\" 开头的项, 其效果取决于 'magic' 选项. 在本章中,
	我们将假定 'magic' 为肯定, 因为那是标准和建议的设定. 如果你把它改了,
	那么, 许多查找模式就会突然变得无效了.

	注意:
	如果你查了好久, 超过了你预计的时间, 你可以中断查找, 在 Unix 上用
	 CTRL-C , 而在 MS-DOS 和微软视窗上则用  CTRL-Break .

==============================================================================
*27.2*	在文件尾折返

在默认情况下, 正向查找从当前光标位置开始, 查找特定的字符串. 然后它就遇到了文
件尾. 如果那个时候还没找到那个字符串, 它就从头来过, 从文件开头一直查到光标处.
   记住, 当你不断以 "n" 命令查找下一个匹配时, 你最终回到第一个匹配. 如果你没
注意, 你将永远找下去! 为了提醒你, Vim 显示如下信息:

	search hit BOTTOM, continuing at TOP ~

如果你使用 "?" 命令按相反方向查找, 你得到的信息是这样的:

	search hit TOP, continuing at BOTTOM ~

可是, 你还是不知道你何时回到第一个匹配. 一种办法是把 'ruler' 选项设为肯定: >

	:set ruler

Vim 将把光标位置显示在窗口的右下角 (在状态条里, 如果它存在). 它看起来像这样:

	101,29       84% ~

第一个数字是光标所在的行码. 在你开始查找的时候记住行码, 那样你就能检查是否越
过了该位置.


无折返查找

要取消查找折返功能, 请用以下命令: >

	:set nowrapscan

现在当查找遇到文件末尾, 一个出错信息就会显示出来:

	E385: search hit BOTTOM without match for: forever ~

因此, 你只要用 "gg" 命令回到文件开头, 并一直查到你看到以上信息, 你就能找到所
有的匹配.
   如果你用 "?" 从相反方向查找, 你得到:

	E384: search hit TOP without match for: forever ~

==============================================================================
*27.3*	偏移

在默认情况下, 查找命令让光标停留在模式的首位. 你可以指定一个偏移, 告诉 Vim 停
留在别的位置上. 在正向查找命令 "/" 中指定偏移, 就是在模式后面附加一个斜线符 
(/) 以及偏移值: >

	/默认/2

这个命令查找模式 "默认", 并让光标越过匹配的模式, 再前移两行, 停留在其首位. 把
这个命令用于以上段落中, Vim 在第一行找到词 "默认". 接着光标再往下移两行, 落在 
"(/)" 上.

如果该偏移为一简单数字, 那么光标就在离匹配正好那么多行的那一行上, 落在其首位. 
该偏移值可为正数或负数. 如果它是正数, 光标再往前移那么多行; 如为负数, 则往回
退那么多行.


字符偏移

偏移符 "e" 表示一个偏移从匹配末尾算起. 它把光标移到匹配的最后一个字符上. 命
令: >

	/const/e

把光标放到单词 "const" 的 "t" 上.
   加一个数字, 光标就从该位置再前移那么多个字符. 这个命令移到匹配后面第一个字
符: >

	/const/e+1

一个正数使光标右移, 负数使其左移. 例如: >

	/const/e-1

把光标移到单词 "const" 的 "s" 字符上.

如果偏移以 "b" 开头, 那么光标就移到模式的首位. 既然不用 "b" 也一样移到首位, 所
以那没什么用. 它变得确实有用, 是在它加上或减去一个数字时. 那时, 光标就会前移或
后移那么多个字符. 例如: >

	/const/b+2

把光标移到匹配的首位, 再往右移两个字符. 因而落在字符 "n" 上.


重复

当你重复前一次使用过的查找模式, 只是偏移不同时, 你可以把模式省略了: >

	/that
	//e

等于: >

	/that/e

再以同样的偏移重复查找: >

	/

命令 "n" 具有同样的作用. 而取消一个以前用过的偏移, 则用: >

	//


后退查找

命令 "?" 以相同的方式使用偏移, 但你必须以 "?" 来分隔模式和偏移, 而非 "/": >

	?const?e-2

偏移符 "b" 和 "e" 保留它们的原意, 它们并不因为使用了 "?" 而改变查找的方向.


起始位置

查找时, 通常从光标位置开始. 当你规定的是一个行偏移, 这可能造成麻烦. 例如: >

	/const/-2

这个命令找到下一个单词 "const", 然后上移两行. 如果你用命令 "n" 再找, Vim 就
从当前位置开始, 找到同一个 "const" 匹配. 然后再一次在偏移的作用下, 回到开始
的地方. 你给套住了!
   还有比这更糟糕的: 假定下一行另有一个 "const" 匹配. 那么, 重复正向查找就会
找到这个匹配, 并上移两行. 这样你实际上把光标往回移了!

当你规定的是一个字符偏移, Vim 将为其作调整. 因此, 查找会向前或向后跳过几个字
符再开始, 以便同一个匹配不至于再出现.

==============================================================================
*27.4*	匹配重复性模式

星号项 "*" 规定在它前面的项可以重复任意次. 因此: >

	/a*

匹配 "a", "aa", "aaa", 等等. 但也匹配 "" (空字串), 因为零次也包含在内.
   星号 "*" 仅仅应用于那个紧邻在它前面的项. 因此 "ab*" 匹配 "a", "ab", "abb",
"abbb", 等等. 如要多次重复整个字符串, 那么该字符串必须组成一个项. 组成一项的
方法, 是在它前面加 "\(", 后面加 "\)". 因此这个命令: >

	/\(ab\)*

匹配: "ab", "abab", "ababab", 等等. 而且也匹配 "".

要避免匹配空字串, 请用 "\+". 这使得前面一项重复一次或多次. >

	/ab\+

匹配 "ab", "abb", "abbb", 等等. 它不匹配 "a", 如果没有 "b" 紧随其后.

要匹配一个任选项, 用 "\=".  例如: >

	/folders\=

匹配 "folder" 和 "folders".


特定重复次数

要重复某一项达特定次数, 使用 "\{n,m}" 这样的形式. 其中 "n" 和 "m" 都是数字. 在
它前面的那个项将被重复 "n" 到 "m" 次 (包含 "n" 和 "m"). 例如: >

	/ab\{3,5}

匹配 "abbb", "abbbb" 以及 "abbbbb".
  当 "n" 省略时, 它就默认为零. 当 "m" 省略时, 它就默认为无限大. 当 ",m" 省略
时, 它就重复正好 "n" 次. 例如:

	模式		匹配次数 ~
	\{,4}		0, 1, 2, 3 或 4
	\{3,}		3, 4, 5, 等等
	\{0,1}		0 或 1, 同 \=
	\{0,}		0 或 更多, 同 * 
	\{1,}		1 或 更多, 同 \+ 
	\{3}		3


匹配尽可能少的字符

迄今为止, 我们提到过的项都试图匹配尽可能多的字符. 若要匹配尽可能少的字符, 请
用 "\{-n,m}". 它的用法跟 "\{n,m}" 一样, 唯一的区别在于, 它采用尽可能少的字符.
   例如, 以下命令: >

	/ab\{-1,3}

将匹配 "abbb" 中的 "ab". 实际上, 因为没理由匹配更多, 所以它永远不会匹配超过
一个 b. 它需要别的什么, 来强制它超过其下限规定次数, 匹配更多的重复.
   这些同样的规则也适用于省略 "n" 和 "m" 的情形. 甚至可以把两个都省略, 只剩
"\{-}". 这个项匹配其前项的重复，重复次数尽可能少，可以等于或大于零. 这个项如
单独使用, 则总是匹配前项的零次重复. 当它跟别的什么合起来时, 用处就大了. 例如: >

	/a.\{-}b

这个命令匹配 "axbxb" 中的 "axb". 如果采用了下面这个模式: >

	/a.*b

它就试图以 ".*" 匹配尽可能多的字符, 因而匹配了整个 "axbxb".

==============================================================================
*27.5*	多择一

在一个查找模式中, "或" 运算符是 "\|". 例如: >

	/foo\|bar

这个命令匹配了 "foo" 或 "bar". 更多的抉择可以连在后面: >

	/one\|two\|three

匹配 "one", "two" 或 "three".
   如要匹配其多次重复, 那么整个抉择结构须置于 "\(" 和 "\)" 之间: >

	/\(foo\|bar\)\+

这个命令匹配 "foo", "foobar", "foofoo", "barfoobar", 等等.
   再举个例子: >

	/end\(if\|while\|for\)

这个命令匹配 "endif", "endwhile" 和 "endfor".

一个与此相关的项是 "\&". 它要求两个抉择都与一处文本相符. 而最终匹配的则是最
后面的那个抉择. 例如: >

	/forever\&...

这个命令匹配 "forever" 中的 "for" (译者: 因为第二抉择要求三个字符). 它将不匹
配, 比如说 "fortuin" (译者: 不符合第一抉择).

==============================================================================
*27.6*	字符域

你可以用 "/a\|b\|c" 来匹配 "a", "b" 或 "c". 当你需要匹配自 "a" 至 "z" 所有的
字母时, 以这样的方式表达就嫌长了. 这儿有个比较简短的表达方式: >

	/[a-z]

方括号结构 [] 匹配单个字符. 你在括号内指定哪些字符可以匹配. 你可以把一系列字
符包含在内, 像这样: >

	/[0123456789abcdef]

这个命令将匹配其中的任何一个字符. 你可以为一系列连续字符规定一个字符域. "0-3" 
表示 "0123". "w-z" 表示 "wxyz". 因此, 上面那个命令可以缩短为: >

	/[0-9a-f]

若要匹配字符 "-" 本身, 就得把它放在字符域的第一或最后的位置上. Vim 认可下面这
些特殊字符, 以便在 [] 字符域里使用它们较为方便 (它们实际上可被用于任何查找模
式):

	\e	<Esc>
	\t	<Tab>
	\r	<CR>
	\b	<BS>

还有若干特殊场合用得上 [] 字符域, 参见 |/[]| 以了解全部用法.


余域

为了避免匹配到一个特定的字符, 在字符域首位使用 "^". 而方括号项 [] 于是就匹配
括号内那些字符以外的任何字符. 例如: >

	/"[^"]*"
<
	 "	  双引号
	  [^"]	  双引号以外的任何字符
	      *	  尽可能多
	       "  又一个双引号

这个命令匹配 "foo" 和 "3!x", 包含双引号在内.


预定义域

有些字符域使用得很频繁. Vim 为这些字符域提供了预定义域这样一条捷径. 例如: >

	/\a

这个命令找寻字母字符. 这相当于使用 "/[a-zA-Z]". 这儿还有几个这样的字符域:

	项	匹配			相当于 ~
	\d	数字			[0-9]
	\D	非数字			[^0-9]
	\x	十六进制数字		[0-9a-fA-F]
	\X	非十六进制数字		[^0-9a-fA-F]
	\s	空白字符		[ 	]     (<Tab> 和 <Space>)
	\S	非空白字符		[^ 	]     (非 <Tab> 和 <Space>)
	\l	小写字母		[a-z]
	\L	非小写字母		[^a-z]
	\u	大写字母		[A-Z]
	\U	非大写字母		[^A-Z]

	注意:
	使用这些预定义的字符域要比使用它们所表示的那个字符域快多了.
	这些项不能用于 [] 方括号内. 因此 "[\d\l]" 不能用来匹配一个数字或一个
	小写字母. 请换用 "\(\d\|\l\)".

参见 |/\s| 以获取一张完整的预定义域列表.

==============================================================================
*27.7*	字符类

一个特定的字符域匹配一组固定的字符. 一个字符类与字符域相似, 不过有个本质的区
别: 那组字符可以重新定义, 但无须改动查找模式.
   例如, 查找这个模式: >

	/\f\+

其中 "\f" 项表示文件名字符. 因而这个命令匹配那些可用作文件名的一连串字符.
   哪些字符可成为文件名的一部分取决于你所使用的系统. 在微软视窗上, 反斜线符
是包含在内的, 而在 Unix 上却不算. 文件名字符由 'isfname' 选项来规定. 在 Unix 
上, 该选项的默认值为: >

	:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=

在其它系统上, 其默认值各不相同. 因此你可以用 "\f" 组成一个查找模式, 以匹配一
个文件名, 而这个查找模式将自动调整以适应你所使用的系统.

	注意:
	实际上, Unix 允许在文件名里使用几乎所有的字符, 包括空格字符. 把这些字
	符包括在 'isfname' 里, 在理论上是没错的. 但那样就无法在文本中发现一个
	文件名在哪儿结束. 选项 'isfname' 的默认值是个折衷方案.

字符类有如下这些:

	项	匹配				选项 ~
	\i	标识符字符			'isident'
	\I	类似于 \i, 但不包括数字
	\k	关键词字符			'iskeyword'
	\K	类似于 \k, 但不包括数字
	\p	可打印字符			'isprint'
	\P	类似于 \p, 但不包括数字
	\f	文件名字符			'isfname'
	\F	类似于 \f, 但不包括数字

==============================================================================
*27.8*	匹配换行符

Vim 能找寻含有换行符的模式. 你需要指定换行符在哪儿出现, 因为迄今为止所有我们
曾经提到过的项, 都不匹配换行符.
   在一个特定的位置查验一个换行符, 请用 "\n" 项: >

	/the\nword

这个命令将在一行以 "the" 结尾, 而下一行以 "word" 开头的地方找到匹配. 如果也
要匹配 "the word", 那么你需要匹配一个空格或一个换行符. 用于这个目的的项是 
"\_s": >

	/the\_sword

若要允许任意数量的空格: >

	/the\_s\+word

这个命令也匹配 "the  " 在行尾, 而 "   word" 在下一行行首的情形.

"\s" 匹配空格字符, "\_s" 匹配空格字符或一个换行符. 同理, "\a" 匹配一个字母字
符, 而 "\_a" 匹配一个字母字符或一个换行符. 其它字符类和字符域都可以插入一个
"_", 以同样的方式作更改.

很多别的项也可以在前面加 "\_" 以匹配一个换行符. 例如: "\_." 匹配任意字符或一
个换行符.

	注意:
	"\_.*" 匹配任何字符, 直至文件结束. 要小心, 它能使一个查找命令非常慢.

另一个例子是 "\_[]", 一个包含了换行符的字符域: >

	/"\_[^"]*"

这个命令找寻的是在一对双引号之间, 分隔成数行的文本.

==============================================================================
*27.9*	举例

这儿有几个查找模式, 你也许会发现有用. 本节向你说明前面提及的那些项可以怎样结
合起来使用.


寻找一个加州驾驶牌照

有一个驾驶牌照号码为 "1MGU103". 它有一个数字, 三个大写字母, 然后三位数字. 直
接把这个号码放入查找模式: >

	/\d\u\u\u\d\d\d

另一种方法是用一个计数来指定其中有三个数字和三个字母: >

	/\d\u\{3}\d\{3}

换用 [] 字符域方法: >

	/[0-9][A-Z]\{3}[0-9]\{3}

这些方法之中你应该使用哪一种? 挑那种你记得住的. 你记得住的简单方法要比你记不
住的华丽方法快得多. 如果你能把它们都记住, 那么避免使用最后那种, 因为它要打的
字多, 而且执行起来慢.


寻找一个标识符

在 C 程序里 (以及其它很多计算机程序) 一个标识符以字母开头, 其余部分由字母和数
字组成. 下划线字符也能用. 这样一个标识符可以用下面的命令找到: >

	/\<\h\w*\>

"\<" 和 "\>" 用来寻找那些完整的词. "\h" 表示 "[A-Za-z_]", 而 "\w" 则表示
 [0-9A-Za-z_]".

	注意:
	"\<" 和 "\>" 取决于 'iskeyword' 选项. 如果这个选项包括, 比如 "-", 那么
	 "ident-" 就不匹配了. 在这种情况下, 请用: >

		/\w\@<!\h\w*\w\@!
<
	这个命令查验是否 "\w" 不匹配标识符之前或之后的字符. (译者: 此处意义
不容易明白, 但原文如此, 译者已力求忠实了.)
	参见 |/\@<!| 和 |/\@!|.

==============================================================================

下一章: |usr_28.txt|  折叠

版权: 参见 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
