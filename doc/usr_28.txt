*usr_28.txt*	For Vim version 6.1.		最后修改: 2001年10月21日

		     VIM 用户手册 - Bram Moolenaar 著
		                    Chimin Yen 译

				   折叠


结构式文本可以分为许多节. 而一节之内可以再分小节. 折叠容许你把一节显示为一行, 
为那一节提供一个综述. 本章将解释各种实现折叠的方法.

|28.1|	什么是折叠?
|28.2|	手动折叠
|28.3|	对折叠的操作
|28.4|	存储和恢复折叠
|28.5|	通过缩进折叠
|28.6|	通过标记折叠
|28.7|	通过文本折叠
|28.8|	通过表达式折叠
|28.9|	折叠未被改动的行
|28.10| 使用哪种折叠办法呢?

下一章: |usr_29.txt|  在代码间移动
前一章: |usr_27.txt|  查找命令及模式
目  录: |usr_toc.txt|

==============================================================================
*28.1*	什么是折叠?

折叠用于把缓冲内某一范围内的文本行显示为屏幕上的一行. 就像一张纸, 要它短些, 就
把它折叠起来:

	+------------------------+
	| line 1		 |
	| line 2		 |
	| line 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / folded lines		  /
	/________________________/
	| line 12		 |
	| line 13		 |
	| line 14		 |
	+------------------------+

那些文本仍然在缓冲内, 没变. 受到折叠影响的只是文本行显示的方式.

折叠的好处是, 通过把多行的一节折叠成带有折叠提示的一行, 你对文本结构的观察更
全面了.

==============================================================================
*28.2*	手动折叠

试一试: 把光标置于某一段落内, 并键入: >

	zfap

你将会看到该段落被一行加亮的文本所代替. 你已经创建了一个折叠. |zf| 是个操作符,
而 |ap| 是一个文本对象选择符. 你可以将 |zf| 操作符跟任何一个移动命令搭配使用,
为所经之处的文本创建一个折叠.  |zf| 也能在可视模式下使用.

若要再阅读那些文本, 请键入以下命令以打开该折叠: >

	zo

并且, 你可以用以下命令再关闭该折叠: >

	zc

所有的折叠命令都以 'z' 开头. 用点儿想像力, 这个字母看起来就像一张折叠起来的纸
的侧面. 而 "z" 后面的字母, 则具有记忆法上的意义, 使得记住这些命令较为容易:

	zf	F-old creation (创建折叠)
	zo	O-pen a fold (打开折叠)
	zc	C-lose a fold (关闭折叠)

折叠可以嵌套: 一个含有折叠的文本区可以被再次折叠. 例如, 你可以折叠本节内每一段
落, 然后折叠本章内所有的节. 试式看. 你将注意到, 打开全章的折叠, 将还原嵌套的折
叠, 跟以前一样, 有些打开, 而有些关闭.

假定你已经创建了若干折叠, 而现在需要阅览全部文本. 你可以移到每个折叠处, 并键
入 "zo". 若要做得更快, 请用这个命令: >

	zr

这将减少 (R-educe) 折叠. 相反的操作是: >

	zm

这将折叠更多 (M-ore). 你 可以重复 "zr" 和 "zm" 来打开和关闭若干层嵌套的折叠.

如果你嵌套了好几层深的折叠, 你可以用这个命令把它们全部打开: >

	zR

这将减少折叠, 直至一个也不剩. 而用这个命令你可以关闭所有的折叠: >

	zM

这将增加折叠, 直至所有的折叠都关闭了.

你可以用 |zn| 命令快速撤除折叠. 然后 |zN| 恢复原来的折叠. |zi| 切换于两者之
间. 以下步骤是一种实用的操作方法:
- 创建折叠, 以获取你的文件的全貌
- 移动到你要操作的地方
- 执行 |zi| 以便一边看着文本, 一边编辑
- 再执行 |zi|  以便移动到另一处

在参考手册中有更多关于手动折叠的内容: |fold-manual|

==============================================================================
*28.3*	折叠的操作

当某些折叠关闭了, 移动命令如 "j" 和 "k" 移动到一个折叠上, 就像它是个简单的空行.
这允许你快速移过折叠了的文本.

你可以复制, 删除和粘贴折叠, 仿佛它是个单行. 这很实用, 假如你要改动某个程序里
的函数的先后次序的话. 首先, 为 'foldmethod' 选择一个正确的折叠方法, 以保证每
个折叠包含了整个函数 (或稍缺一点儿). 然后, 用 "dd" 命令删除该函数, 移动光标, 
并用 "p" 命令粘贴. 如果函数中某些行在折叠之上, 或之下, 你可以利用可视模式下的
选择方法:
- 把光标置于被移文本的首行
- 击 "V" 键开始可视模式
- 把光标置于被移文本的末行
- 击 "d" 键删除被选中的行.
- 把光标移到新位置, 并击 "p" 键把文本粘贴在那儿.

有时候, 查看或记住一个折叠在哪儿, 挺不容易的, 而那儿也正是 |zo| 命令实际有效
的地方. 要查看那些已定义的折叠: >

	:set foldcolumn=4

这个命令将在窗口左边显示一小栏来表示折叠状态. 一个 "+" 表示某个关闭的折叠. 一
个 "-" 表示每个打开的折叠的开头, 而 "|" 则表示该折叠内其余的行.

你可以在折叠栏内用鼠标点击 "+" , 以打开一个折叠. 点击 "-" , 或在它之下的某个 
"|" , 将关闭一个打开的折叠.

打开所有光标行上的折叠, 请用 |zO|.
关闭所有光标行上的折叠, 请用 |zC|.
删除一个光标行上的折叠, 请用 |zd|.
删除所有光标行上的折叠, 请用 |zD|.

当你进入插入模式后, 光标行上的折叠永远不会关闭. 那是要让你看见你打的什么字!

当光标前后跳转至折叠, 或在折叠上左右移动时, 折叠就会自动打开. 例如, 零命令 
"0" 打开光标下的折叠 (假设 'foldopen' 包含 "hor", 即默认设置). 'foldopen' 
选项可以修改, 为指定的某一类命令打开折叠. 如果你要光标遇到折叠, 折叠就打开, 
那么可以这么做: >

	:set foldopen=all

警告: 你将因此无法移到一个关闭的折叠上. 你也许只想临时用一用这个命令, 然后把
它设回默认值: >

	:set foldopen&

你可以在移开折叠时自动关闭折叠: >

	:set foldclose=all

这个命令将重新把折叠层次 'foldlevel' 作用到所有的不含光标的折叠. 你必须动手
试一试, 如果你想体会一下这个命令的作用. 请用 |zm| 折叠更多的层次, 并用 |zr| 
折叠更少的层次 (减少折叠的层次).

折叠是该窗口的本地行为. 这容许你为同一缓冲打开两个窗口, 一个带折叠, 而另一个
不带折叠. 或者, 一个让所有的折叠关闭, 而另一个则让所有的折叠打开.

==============================================================================
*28.4*	存储和恢复折叠

当你放弃一个文件时 (开始编辑另一个), 其折叠状态就丧失了. 如果你稍后再回来编辑
同一文件, 那么, 所有手动打开和关闭的折叠, 全都恢复到它们的默认状态了. 如果折叠
是用手动方式创建的, 则所有的折叠都消失了! 为了保存折叠, 请用 |:mkview| 命令: >

	:mkview

这将储存那些影响文件视图的设定及其它内容. 你可以利用 'viewoptions' 选项修改储
存的范围. 当你稍后回到同一文件时, 你可以重新载入这个视图: >

	:loadview

你可以为一个文件储存多至十个视图. 例如, 把当前设置储存为第三个视图, 并载入第
二个视图: >

	:mkview 3
	:loadview 2

注意, 当你插入或删除一些文本行时, 视图可能变得无效. 还得检查 'viewdir' 选项, 
它指定视图文件储存在哪儿. 你也许不时需要删除旧的视图文件.

==============================================================================
*28.5*	通过缩进折叠

使用 |zf| 来定义一个折叠很费事. 如果你的文本形成一种结构, 以较多的缩进表示较
低的层次, 那么, 你可以采用缩进折叠的方法. 这将为每一串有相同缩进的行创建折叠. 
缩进较多的行将成为嵌套的折叠. 缩进折叠适用于许多编程语言.

试试这个方法, 先设定 'foldmethod' 选项: >

	:set foldmethod=indent

然后你可以用 |zm| 和 |zr| 命令增加和减少折叠. 在下面这个例文上很容易看明白:

This line is not indented
	This line is indented once
		This line is indented twice
	This line is indented once
This line is not indented
	This line is indented once
	This line is indented once

注意, 缩进多少和折叠深度之间的关系倚赖于 'shiftwidth' 选项. 每个 'shiftwidth'
选项规定的缩进宽度, 在折叠深度上加一. 这称为一层折叠层.

当你使用 |zr| 和 |zm| 命令时, 你实际上增加或减少了 'foldlevel' 选项. 你也可
以直接设置它: >

	:set foldlevel=3

这意味着, 所有的折叠, 其缩进等于或大于 'shiftwidth' 的三倍, 将被关闭. 折叠层
设得越低, 则越多的折叠将被关闭. 当 'foldlevel' 为零时, 所有的折叠都被关闭. 
|zM| 确实把 'foldlevel' 设为零. 相反的命令 |zR| 把 'foldlevel' 设为文件中最
深的折叠层.

因此, 有两种方法开启和关闭折叠:
(A) 设定折叠层.
    这提供了一种极快的 "缩小" 方法来查看文本结构, 移动光标, 以及重新 "放大" 
    文本.

(B) 利用 |zo| 和 |zc| 命令打开和关闭指定的折叠.
    这个方法容许你在其它折叠仍然关闭时, 仅仅打开那些你要打开的折叠.

这两种方法可以结合起来用: 你可以先用几次 |zm| 以关闭大多数折叠, 然后用 |zo| 
打开一个指定的折叠. 或者, 用 |zR| 打开所有的折叠, 然后用 |zc| 关闭指定的折叠.

然而, 当折叠方法 'foldmethod' 设为 "indent" 时, 你不能手动定义折叠, 那会与缩
进宽度和折叠层次之间的关系起冲突.

在参考手册中有更多关于缩进折叠的内容: |fold-indent|

==============================================================================
*28.6*	通过标记折叠

文本中的标记用于指定一个折叠区的起点和终点. 标记折叠可以精确地控制一个折叠究
竟包含哪几行文本. 缺点是那些文本需要改动.

试试这个: >

	:set foldmethod=marker

以下文为例, 正如它可能出现在一个 C 程序里:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

请注意, 折叠行将显示位于标记符之前的文字. 这正好用来说明该折叠包含了什么.

令人十分困扰的时候是, 当某些文本行移动后, 标记不再正确地配对. 这种局面可以利
用编号标记来避免. 例如:

	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

在每一个编号标记处, 都有一个指定层次的折叠开始. 这将使任何较高层次的折叠在此
结束. 你可以只用编号标记的开始符定义所有的折叠. 只有当你要明确地在另一个开始
前结束一个折叠时, 你才需要加一个标记停止符.

在参考手册中有更多关于标记折叠的内容: |fold-marker|

==============================================================================
*28.7*	通过文法折叠

Vim 为每一种不同的语言使用一个不同的文法文件. 文法文件为文件中各种不同项目定
义色彩. 如果你正用 Vim 在一个支持色彩的终端上阅读本文, 你所看见的色彩就是由 
文法文件 "help" 定制的.
   在文法文件中, 你可以加入一些带有 "fold" 参数的文法项目. 这些项目定义的是折
叠区. 这要求写一个文法文件, 把这些项目加入其中. 这个文件不容易写. 但是一旦写
成, 所有的折叠就自动发生.
   在此, 我们将假定你正使用着一个写好的文法文件. 这样的话, 就没更多的需要解
释了. 你可以打开和关闭折叠, 就像以上解释过的那样. 你也可以在编辑文件时自动创
建和删除那些折叠.

在参考手册中有更多关于文法折叠的内容: |fold-syntax|

==============================================================================
*28.8*	通过表达式折叠

表达式折叠类似于缩进折叠, 但并非利用文本行的缩进, 而是调用一个函数来计算一行
的折叠层次. 你可以在那些对于哪些行应相属在一起有所提示的文本内使用表达式折叠.
一个例子是电子邮件报文, 其中引述的文本由行首的 ">" 来表示. 要折叠这些引文, 请
用以下命令: >

	:set fxieoldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

你可以在这段文本上试式看:

> quoted text he wrote
> quoted text he wrote
> > double quoted text I wrote
> > double quoted text I wrote

以下是上例中 'foldexpr' 的解释 (自里至外):
   getline(v:lnum)			读取当前行
   substitute(...,'\\s','','g')		从当前行删除所有空白字符
   substitute(...,'[^>].*','',''))	删除行首那些 '>' 之后的任何字符
   strlen(...)				计数字符串的长度, 即 '>' 的个数

注意, 在 ":set" 命令中, 每一个空格, 双引号和反斜线符之前, 必须插入一个反斜线
符. 如果因此让你觉得混淆, 那么就执行  >

	:set foldexpr

以检查所产生的实际值. 为了修改一个复杂的表达式, 请使用命令行补足: >

	:set foldexpr=<Tab>

其中 <Tab> 是一个真实的 Tab 键. Vim 将填入以前的值, 然后你可以编辑它.

在参考手册中有更多关于表达式折叠的内容: |fold-expr|

==============================================================================
*28.9*	折叠未被改动的行

当你在同一窗口也设定 'diff' 选项时, 这种未改行折叠就很有用. |vimdiff| 命令为
你设定好了未改行折叠. 例如: >

	setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

在显示同一文件的不同版本的窗口内执行这个命令. 由于那些没改动的文本都折叠了, 
你将清楚地看到不同文件间的区别.

更多细节参见 |fold-diff|.

==============================================================================
*28.10* 使用哪种折叠办法呢?

所有这些可能性让你感到纳闷, 你究竟应该选择哪种方法. 不幸的是, 并无黄金法则.
但这儿有些提示.

如果存在一个文法文件, 其中定义的折叠符合你正在编写的程序语言, 那么, 文法折叠
也许就是最好的选择了. 否则, 你也许得试着写一个. 这要求你具备关于查找模式的良
好知识. 那不容易写, 但一旦写成, 你将不必以手动的方式定义折叠了.

键入命令, 手动折叠一个个文本区的方法可用于无结构特点的文本. 然后用 |:mkview|
命令来储存和还原折叠状态.

标记折叠法要求你修改文件. 如果你与其它人共享这个文件, 或不得不遵守公司规定的
标准, 那么你也许得不到许可给文件加标记.
   标记折叠的主要优点是, 你可以精确的把标记放在你要的位置. 那样就避免了那种在
你剪切和粘贴折叠时漏了几行文本的情况. 并且, 你还可以加个注释, 说明该折叠包含
些什么.

缩进折叠法是那种在许多文件里都能用, 但并非经常很成功的方法. 当你无法采用其它
方法时, 就用这种. 然而, 缩进折叠在做提纲时特别有用. 你为每一层嵌套折叠特意采
用同一缩进宽度 'shiftwidth' .

表达式折叠法能够在几乎任何种类的结构式文本中创建折叠. 这种方法相当简单, 尤其
是, 如果一个折叠的开始和结束处能容易地被识别.
   如果你用 "expr" 方法来定义折叠, 但它们却不完全是你要的那样, 那么你可以切换
到手动方法 "manual" . 这么做将不会删除那些已经定义好了的折叠. 因此你便可以手
动删除或增加折叠了.

==============================================================================

下一章: |usr_29.txt|  在代码间移动

版权: 参见 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
